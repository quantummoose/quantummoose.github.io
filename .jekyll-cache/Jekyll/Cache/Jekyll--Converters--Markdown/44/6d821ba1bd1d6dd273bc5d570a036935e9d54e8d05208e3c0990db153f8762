I"d=<p>I’ve been using <a href="https://en.wikipedia.org/wiki/Partial_least_squares_regression">partial least squares</a> analysis for a while now, but still learning about it. The core idea of PLS is really not complicated at all, but using it appropriately and fully understanding the model takes work.</p>

<p>What’s the core idea? In short, PLS combines both principle components analysis and standard regression - instead of simply regressing Y against X, you find the best lower dimensions \(Y_{low}\) and \(X_{low}\) such that \(Y_{low}\) regresses against \(X_{low}\). The code for running PLS in MATLAB is very simple, since there’s a built in <a href="https://www.mathworks.com/help/stats/plsregress.html">plsregress</a> function, but it’s a bit obtuse<label for="one" class="margin-toggle sidenote-number"></label><input type="checkbox" id="one" class="margin-toggle" /><span class="sidenote">Though this might be due to my own background </span>. I’m not going to go through <a href="http://setosa.io/ev/principal-component-analysis/">PCA</a> and <a href="http://setosa.io/ev/ordinary-least-squares-regression/">regression</a>; I’m just going to assume we know those things.</p>

<p>For regression in general, we fit the equation \(Y = \beta   X + \epsilon\) where we want to predict Y from X, using the \(\beta\) regression weights or coefficients. \(\epsilon\) is just the error term here. So let’s assume we want to predict some behavioral response, like reaction time, from some neural signal<label for="two" class="margin-toggle sidenote-number"></label><input type="checkbox" id="two" class="margin-toggle" /><span class="sidenote">Assume all the values are centered. </span>, so reaction time = Y <label for="three" class="margin-toggle sidenote-number"></label><input type="checkbox" id="three" class="margin-toggle" /><span class="sidenote">Y is a <em>trial</em> x 1 vector </span> and brain signals = X <label for="four" class="margin-toggle sidenote-number"></label><input type="checkbox" id="four" class="margin-toggle" /><span class="sidenote">X is a <em>trial</em> by <em>features</em> matrix, where features are just number of signals we have on each trial, like average voxel signal </span>. However, we measure a large amount of different features that may or may not be important. Presumably only some of them are.</p>

<p>First, let’s generate some fake data in MATLAB:</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Generating fake data:</span>
<span class="n">ntrials</span> <span class="o">=</span> <span class="mi">300</span><span class="p">;</span>
<span class="c1">% Only the hidden state determines response:</span>
<span class="n">HiddenState</span> <span class="o">=</span> <span class="nb">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ntrials</span><span class="p">);</span>
<span class="n">Response</span> <span class="o">=</span> <span class="n">HiddenState</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">+</span> <span class="nb">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">ntrials</span><span class="p">);</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">HiddenState</span><span class="p">,</span> <span class="n">Response</span><span class="p">,</span> <span class="s1">'.'</span><span class="p">)</span>

<span class="c1">% Now unrelated noise states:</span>
<span class="n">OtherStates</span> <span class="o">=</span> <span class="nb">randn</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">ntrials</span><span class="p">);</span>
<span class="c1">% Project those states into a higher dimension.</span>
<span class="n">linproj</span> <span class="o">=</span> <span class="nb">randn</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
<span class="n">XObs</span> <span class="o">=</span> <span class="p">[</span><span class="n">HiddenState</span><span class="s1">', OtherStates'</span><span class="p">]</span> <span class="o">*</span> <span class="n">linproj</span><span class="p">;</span>
</code></pre></div></div>
<p><label for="one" class="margin-toggle">⊕</label><input type="checkbox" id="one" class="margin-toggle" /><span class="marginnote"><img class="fullwidth" src="/assets/img/pls/pls1.png" /><br />plot(HiddenState, Response, ‘.’)</span></p>

<p>So what did I do here? I created some fake regression data, where our response is predicted from the Hidden State. However, I combined the hidden state with other random states that are unimportant for prediction. <code class="language-plaintext highlighter-rouge">linproj</code> is a matrix that basically puts your 10 states (combined hidden and noise) into a higher level space (30 dimensions). This kinda replicates what often happens to our measurement. We measure a bunch of signals that are highly correlated, with only a few actually important changing states. Now what happens if we go ahead and perform regression, regressing the 30 features of Xobs against the 1 Response?</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nb">beta</span> <span class="o">=</span> <span class="n">XObs</span><span class="p">\</span><span class="n">Response</span><span class="o">'</span><span class="p">;</span> <span class="c1">% Solve simple regression in matlab.</span>
<span class="n">Warning</span><span class="p">:</span> <span class="n">Rank</span> <span class="n">deficient</span><span class="p">,</span> <span class="nb">rank</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">tol</span> <span class="o">=</span>  <span class="mf">1.775230e-11</span><span class="o">.</span>
</code></pre></div></div>
<p>So MATLAB already figured out that most of the dimensions aren’t predictive. We accidentally got back we only have 10 states. Our regression here actually works pretty well (in terms of fit), but it’s really overfitting all the noisy dimensions.</p>

<p>What if most of the features in X are either redundant or not really important for predicting? Well we could go ahead and perform PCA on the XObs to find what dimensions actually are important, \(XObs = Xlow   U_L\) where we only choose L components from the projection matrix U <label for="five" class="margin-toggle sidenote-number"></label><input type="checkbox" id="five" class="margin-toggle" /><span class="sidenote">PCA decomposes X into two matrices, UDU’ where U is a projection matrix and D is a diagonal matrix. SVD breaks a matrix into three matrices where U’ = V. </span>. In MATLAB we can do this by performing SVD on the covariance matrix of the features.</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CObs</span> <span class="o">=</span> <span class="nb">cov</span><span class="p">(</span><span class="n">XObs</span><span class="p">);</span>
<span class="p">[</span><span class="n">U</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">V</span><span class="p">]</span> <span class="o">=</span> <span class="nb">svd</span><span class="p">(</span><span class="n">CObs</span><span class="p">);</span>
<span class="c1">% Find percent variance explained:</span>
<span class="nb">cumsum</span><span class="p">(</span><span class="nb">diag</span><span class="p">(</span><span class="n">S</span><span class="p">)/</span><span class="nb">sum</span><span class="p">(</span><span class="nb">diag</span><span class="p">(</span><span class="n">S</span><span class="p">)))</span>
</code></pre></div></div>
<p>We find that we can explain over 80% of the variance with one component, and only need 10 components to explain everything. So we could go ahead and use those new lower dimensions for regression:</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Xpca_scores</span> <span class="o">=</span> <span class="n">XObs</span> <span class="o">*</span> <span class="n">U</span><span class="p">(:,</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">);</span>
<span class="n">beta2</span> <span class="o">=</span> <span class="n">Xpca_scores</span><span class="p">\</span><span class="n">Response</span><span class="o">'</span><span class="p">;</span>
</code></pre></div></div>
<p>Again, if we only cared about fit here we do a good job, but again there’s a worry of overfit. There’s also another worry: if this was bad at predicting how do we assign blame? Which was the problem, the PCA or the regression? Now what if we wanted to <em>use</em> those hidden states; did we grab the <em>right</em> hidden states? If we wanted to somehow use the regression <em>with</em> the PCA to find the hidden state that’s important at predicting the response, then we’d have to combine these ideas.</p>

<p>That’s what PLS does. Partial Least Squares is named based on a comparison with the least squares method for regression<label for="six," class="margin-toggle sidenote-number"></label><input type="checkbox" id="six," class="margin-toggle" /><span class="sidenote">Interestingly, the co-creater of PLS, Svante Wold, <a href="http://www.sciencedirect.com/science/article/pii/S0169743901001551">prefers the name</a> <em>projection to latent structures</em>, which is much more explanatory. </span>. PCA only minimizes reconstruction error, while regression minimizes least squares fit error. PLS tries to find the lower dimension that best predicts the response Y (using ‘partial’ least squares). It’s a type of <em>directed dimensionality reduction</em>.</p>

<p>A way to visualize the model of PLS is below. This graphic shows each matrix that PLS is working with, and how they relate. Here our data of predictors is X with responses Y, and the scores refer to the points in a lower dimension space.</p>
<figure><img src="/assets/img/pls/pls4.jpg" /><figcaption class="maincolumn-figure">PLS image taken from <a href="https://www.intechopen.com/books/multivariate-analysis-in-management-engineering-and-the-sciences/application-of-multivariate-data-analyses-in-waste-management">here</a>.</figcaption></figure>
<p>To relate to our equations, our \(Xscores = T\) and \(Yscores = U\), and the regression takes place as \(U = B   T\), where \(B\) are the regression coefficients that relate X to Y through the lower dimensions.</p>

<p>In MATLAB, it’s simple:</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ncomp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">% Choose the number of components.</span>
<span class="p">[</span><span class="n">Xlow</span><span class="p">,</span> <span class="n">Ylow</span><span class="p">,</span> <span class="n">Xscores</span><span class="p">,</span> <span class="n">Yscores</span><span class="p">,</span> <span class="nb">beta</span><span class="p">]</span> <span class="o">=</span> <span class="n">plsregress</span><span class="p">(</span><span class="n">Xobs</span><span class="p">,</span><span class="n">Response</span><span class="o">'</span><span class="p">,</span><span class="n">ncomp</span><span class="p">);</span>
</code></pre></div></div>
<p><label for="two" class="margin-toggle">⊕</label><input type="checkbox" id="two" class="margin-toggle" /><span class="marginnote"><img class="fullwidth" src="/assets/img/pls/pls2.png" /><br />plot(Xscores, HiddenState, ‘.’). Note we don’t completely recover the original states</span>
Note that PLS can deal with multiple Y dimensions as well, fitting a lower Y state (here Ylow, which we ignore). The scores are the projected lower dimension values, while the Xlow and Ylow are the projection matrices, so <code class="language-plaintext highlighter-rouge">Response = Yscores * Ylow'</code> and <code class="language-plaintext highlighter-rouge">XObs = Xscores *  Xlow'</code>. The beta weights here are the weights<label for="seven" class="margin-toggle sidenote-number"></label><input type="checkbox" id="seven" class="margin-toggle" /><span class="sidenote">including intercept </span> <em>in the higher dimension space</em>, which is incredibly important. So <code class="language-plaintext highlighter-rouge">Response = Xobs*beta(2:end)</code>, rather than being the weights in the lower dimension. You would have to project down using Xlow to get those values. In other words, \(B = \beta \times  Xlow\).</p>

<p>Notice we had to choose a number of components. <code class="language-plaintext highlighter-rouge">plsregress</code> will actually output percent variance explained and mean squared error for fits from 1 to ncomp, so we can use that to decide the number of components. Which value we use largely depends on how we use the results of the model fit. Here we care mostly if we get the score values corresponding to the hidden state, so we have an external way to check.</p>

<p>For a geometric visualization of PLS, below we can see both the plane defined by the dimensionality reduction, and the line for the regression.</p>
<figure><img src="/assets/img/pls/pls3.png" /><figcaption class="maincolumn-figure">From <a href="http://www.iasbs.ac.ir/chemistry/chemometrics/history/4th/5.pdf">Wold, Sjostrom, and Eriksson 2001</a></figcaption></figure>
<p>The data from X fall on the plane, but follow the line (with noise). The line and components are chosen to induce a best correlation fit to the response Y.</p>

<p>That’s a brief introduction into PLS, hopefully useful. I have a <a href="https://gist.github.com/quantummoose/ca12fea5c1285bbc9742d47bbc4dfc9b">gist of the code used</a> if you’d like to see that. More detailed explanations exist for the model specifications if you’re interested<label for="eight" class="margin-toggle sidenote-number"></label><input type="checkbox" id="eight" class="margin-toggle" /><span class="sidenote">Look at Kevin Murphy’s <em>Machine Learning: a Probabilistic Approach</em> for a good comparison of the generative model of PLS to other methods, including CCA and PCA </span>. It’s good for me to think through it sometimes.</p>

<p>PLS isn’t the only method of performing directed dimensionality reduction, and it’s also not the only way to deal with regression with high correlation in the features. For example, <a href="https://stats.stackexchange.com/questions/206587/what-is-the-connection-between-partial-least-squares-reduced-rank-regression-a">canonical correlation</a> analysis is similar to PLS, but considers X and Y equivalent in that there isn’t one ‘predictor’. PLS is also used for <a href="http://hbanaszak.mjr.uw.edu.pl/TempTxt/HaenleinKaplan_2004_BeginnersGuideToPLSAnalysis.pdf">structural equation modeling</a>, a topic I understand very little, but is related in behavioral research.</p>

<p>Really it depends on the type of data you have, and the type of question you’re interested in. The goal either way is to move beyond just simple regression, to get at the latent structure underlying the data.</p>

<p>Brief note: these are deeply related to <a href="https://en.wikipedia.org/wiki/Autoencoder">autoencoders</a>, a type of neural network. PLS basically specifies a particular network structures, based on the type of generative model.</p>
:ET